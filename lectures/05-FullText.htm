<html>
    <head>
<style>
body {
    font-family: sans-serif;
}
</style>
    </head>
    <body>
<h1>PostgreSQL Full Text Lecture Notes</h1>
<p>
In this lecture we will explore how PostgreSQL indexes work and how we build indexes
for large text fields that contain natural language
and how we can look into those fields and use indexes to search large text fields efficiently.
</p>
<h2>Row Data Layout</h2>
<p>
Rows can vary quite a bit in terms of length.
<pre>
CREATE TABLE messages
 (id SERIAL,              -- 4 bytes
  email TEXT,             -- 10-20 bytes
  sent_at TIMESTAMPTZ,    -- 8 bytes
  subject TEXT,           -- 10-100 bytes
  headers TEXT,           -- 500-1000 bytes
  body TEXT               -- 50-2000 bytes
                          -- 600-2500 bytes
);
</pre>
<p>
Since modifying data is so important to databases, we don't pack store one row after another in a file.
We arrange the file into blocks (default 8K) and pack the rows into blocks leaving some free space
to make inserts updates, or deletes possible without needing to rewrite a large file to move
things up or down.
</p>
<div style="float: right; width: 50%; min-width: 250;"><a href="05-FullText/postgres-disk-blocks.png" target="_blank">
<img src="05-FullText/postgres-disk-blocks.png" style="width: 100%;">
</a></div>
<p>
PostgreSQL Organizes Rows into Blocks
<ul>
    <li>We read an entire block into memory (i.e. not just one row)</li>
    <li>Easy to compute the start of a block within a file for random access</li>
    <li>There are the unit of caching in memory</li>
    <li>They are (often) the unit of locking when we think we are locking a row</li>
</ul>
</p>
<p>
What is the Best Block Size?
<ul>
    <li>Blocks that are small waste free space / fragmentation</li>
    <li>Large blocks take more memory in cache be cached for a given memory size</li>
    <li>Large blocks longer to read and write to/from SSD </li>
</ul>
<p>
If we have a table that contains 1GB (125,000 blocks) of data, a sequential scan from a
fast SSD takes about 2 seconds while with careful optimization, reading a random block
can be fast as 1/50000th of a second.  Some SSD drives can read up to 32 different
random blocks in a single read request.  If the block is already in memory it is even
faster.  Sequential scans are very bad.
</p>

<b>References</b>
<ul>
    <li>
<a href="https://malisper.me/the-file-layout-of-postgres-tables/" target="_blank">
    The File Layout of Postgres Tables</a> (Blog Post)
    </li>
    <li>
        <a href="http://rachbelaid.com/introduction-to-postgres-physical-storage/" target="_blank">
            Introduction to PostgreSQL physical storage
        </a> (Blog Post)
    </li>
    <li><a href="https://blog.pgaddict.com/posts/postgresql-on-ssd-4kb-or-8kB-pages" target="_blank">
            PostgreSQL on SSD - 4kB or 8kB pages?
        </a> (Blog Post)
    </li>
</ul>
<br clear="all"/>
<h2>Indexes</h2>
<p>
Assume each row in the <b>users</b> table is about 1K, we could save a lot of time if somehow we had a hint
about which row was in which block.
<pre>
email              | block
-------------------+------
anthony@umich.edu  | 20175
csev@umich.edu     | 14242
colleen@umich.edu  | 21456

SELECT name FROM users WHERE email='csev@umich.edu';
SELECT name FROM users WHERE email='colleen@umich.edu';
SELECT name FROM users WHERE email='anthony@umich.edu';
</pre>
Our index would be about 30 bytes per row which is much smaller than the actual row data.  We store index data in 8K
blocks as well - as indexes grow in size we need to find was to avoid reading the entire index to look up one key.
We need an index to the index.  For string logical keys, a B-Tree index is a good, general solution.
B-Trees keep the keys in sorted order by reorganizing the tree as keys are inserted.
</p>
<p>
PostgreSQL Index Types
<ul>
    <li>B-Tree - The default for many applications - automatically balanced as it grows</li>
    <li>BRIN - Block Range Index - Smaller / faster if data is mostly sorted</li>
    <li>Hash - Quick lookup of long key strings</li>
    <li>GIN - Generalized Inverted Indexes - multiple values in a column</li>
    <li>GiST - Generalized Search Tree</li>
    <li>SP-GiST - Space Partitioned Generalized Search Tree</li>
</ul>
</p>
<b>References</b>
<ul>
    <li><a href="http://www.postgresqltutorial.com/postgresql-indexes/postgresql-index-types/" target="_blank">
            PostgreSQL Index Types</a> (Blog Post)
    </li>
    <li><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank">
            B-Tree Index</a> (WikiPedia)
    </li>
    <li><a href="https://en.wikipedia.org/wiki/Block_Range_Index" target="_blank">
            Block Range Index</a> (WikiPedia)
    </li>
</ul>

<h2>Forward and Inverted Indexes</h2>
<p>
It is not a perfect metaphor but in general there are two categories of indexes:
<ul>
    <li><b>Forward indexes</b> - You give the index a logical key and it tells you where to find the row
        that contains the key. (B-Tree, BRIN, Hash)</li>
    <li><b>Inverse indexes</b> - You give the index a string (query) and the index gives you a list of <i>all</i>
        the rows that match the query. (GIN, GiST)</li>
</ul>
The metaphor is not perfect - because B-tree indexes are stored in sorted order, if you give
a B-Tree the prefix of a logical key, it can give you a set of rows...
</p><p>
The most typical use case for an <b>Inverse index</b> is to quickly search text documents wit one or a few words.
</p> 
<b>References</b>
<ul>
    <li>
<a href="https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices" target="_blank">
    https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices
</a></li>
</ul>
<h2>
    Similar to Google Search
</h2>
<ul>
    <li>Crawl: Retrieve documents, parse them and create an <b>inverted index</b></li>
    <li>Search: Take keywords, find the documents with the words then rank them and present results</li>
</ul>
<b>References</b>
<ul>
    <li><a href="https://youtu.be/6x0cAzQ7PVs?t=559" traget="_blank">
            Google I/O '08 Keynote by Marissa Mayer</a></li>
    <li><a href="https://www.youtube.com/watch?v=BNHR6IQJGZs" target="_blank">
            How Search Works - Matt Cutts</a></li>
</ul>

<h2>Inverted Indexes - The Hard Way
</h2>
<div style="float: right; width: 25%; min-width: 250;"><a href="05-FullText/inverted-index.png" target="_blank">
<img src="05-FullText/inverted-index.png" style="width: 100%;">
</a></div>
<ul>
    <li> <a href="https://stackoverflow.com/questions/29419993/split-column-into-multiple-rows-in-postgres"
            target="_blank">Unest - S.O.</a></li>
</ul>





<br clear="all"/>
<h2>Inverted Indexes - Stop Word
</h2>
<div style="float: right; width: 25%; min-width: 250;"><a href="05-FullText/inverted-index-stop.png" target="_blank">
<img src="05-FullText/inverted-index-stop.png" style="width: 100%;">
</a></div>
<ul>
    <li> <a href="https://stackoverflow.com/questions/29419993/split-column-into-multiple-rows-in-postgres"
            target="_blank">Unest - S.O.</a></li>
</ul>

<h2>Inverted Indexes in PostgreSQL
</h2>
<ul>
    <li>Generalized Inverse Index (GIN)</li>
    <li>Generalized Search Tree (GiST)</li>
</ul>

<b>References</b>
<ul>
    <li><a href="https://www.postgresql.org/docs/10/textsearch-indexes.html" target="_blank">
            Text Searches in PostgreSQL</a></li>
</ul>

<h2><a href="https://www.postgresql.org/docs/10/textsearch-intro.html" target="_blank">https://www.postgresql.org/docs/10/textsearch-intro.html</a></h2>
<ul>
    <li>SQL LIKE and Regex scan text columns and can even build indexes but are not "language-aware"</li>
    <li>Full Text is language aware (i.e. "stop words" and "lexemes") more like a search engine</li>
</ul>

<pre>
https://www.postgresql.org/docs/9.6/functions-textsearch.html


A tsvector value is a sorted list of distinct lexemes, which are words that have been normalized to merge different variants of the same word.  Position / weight (A-D)

SELECT to_tsvector('have a nice day');
   to_tsvector
------------------
 'day':4 'nice':3

A tsquery value stores lexemes that are to be searched for, and combines them honoring the Boolean operators

pg4e=> SELECT to_tsquery('have & a & nice & day');
   to_tsquery
----------------
 'nice' & 'day'

Text query operators

SELECT to_tsvector( 'have a nice day' ) @@ to_tsquery( '''have a nice day''' );
SELECT to_tsvector( 'have a nice day' ) @@ plainto_tsquery( 'have a nice day' );
SELECT to_tsvector( 'have a nice day' ) @@ plainto_tsquery( 'day nice' );
SELECT to_tsvector( 'have a nice day' ) @@ phraseto_tsquery('nice day');
SELECT to_tsvector( 'have a nice day' ) @@ phraseto_tsquery('day nice');

-- Required PostgreSQL 11
SELECT to_tsvector( 'have a nice day' ) @@ websearch_to_tsquery('english', 'days of wine and roses');
SELECT to_tsvector( 'have a nice day' ) @@ to_tsquery( 'have & a & nice  & day' );
SELECT to_tsvector( 'have a nice day' ) @@ to_tsquery( 'day & nice' );

CREATE INDEX pictures_title ON pictures
  USING gin(to_tsvector('english', title));

ts_vector
ts_query
GIN  - Generalized inverted - Perfect - Slow update, fast select
GiST - Generalized Search Tree - Lossy - Hash - Fast update, slow select

SHOW default_text_search_config;
\dF

Index Types
GIN - Words not LIKE
GiST - Words not LIKE
https://en.wikipedia.org/wiki/Block_Range_Index

SELECT to_tsvector('It''s kind of fun to do the impossible') @@ to_tsquery('impossible');

Ranking...

CREATE INDEX pictures_title ON pictures
  USING gin(to_tsvector('english', title));


SELECT substring(content, '0([0-9][0-9])0') AS num FROM content;

References

https://www.compose.com/articles/indexing-for-full-text-search-in-postgresql/
https://stackoverflow.com/questions/4014519/fulltext-query-with-scores-ranks-in-postgresql/4014625#4014625
https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING
https://stackoverflow.com/questions/12933805/best-way-to-use-postgresql-full-text-search-ranking

https://www.postgresql.org/docs/9.5/brin-intro.html
https://en.wikipedia.org/wiki/Block_Range_Index
https://www.postgresql.fastware.com/blog/brin-indexes-what-are-they-and-how-do-you-use-them




WEEK 2 - JSON / KEY-VALUE DATA
==============================

https://stackoverflow.com/questions/18404055/index-for-finding-an-element-in-a-json-array

JSON - Text + some functions.
JSOB - Parsed objects - More awesome.
@> being the new jsonb "contains" operator, which can use the GIN index. (Not for type json, only jsonb!)

With the new binary JSON data type jsonb, Postgres 9.4 introduced largely improved index options. You can now have a GIN index on a jsonb array directly:

CREATE TABLE tracks (id serial, artists jsonb);
CREATE INDEX tracks_artists_gin_idx ON tracks USING gin (artists);

No need for a function to convert the array. This would support a query:

SELECT * FROM tracks WHERE artists @> '[{"name": "The Dirty Heads"}]';

@> being the new jsonb "contains" operator, which can use the GIN index. (Not for type json, only jsonb!)

Or you use the more specialized, non-default GIN operator class jsonb_path_ops for the index:

CREATE INDEX tracks_artists_gin_idx ON tracks
USING  gin (artists jsonb_path_ops);

Same query.

Currently jsonb_path_ops only supports the @> operator. But it's typically much smaller and faster. There are more index options, details in the manual.

https://stackoverflow.com/questions/24006291/postgresql-return-result-set-as-json-array

create table t (a int primary key, b text);

insert into t values (1, 'value1');
insert into t values (2, 'value2');
insert into t values (3, 'value3');

select row_to_json(row) from (select * from t) row;

Store Types:
HSTORE
JSON
JSONB


Casting using :: or CAST(value AS type)
https://stackoverflow.com/questions/15537709/what-does-do-in-postgresql
https://stackoverflow.com/questions/5758499/double-colon-notation-in-sql

Operators @>
https://www.postgresql.org/docs/9.5/functions-json.html

Contain

'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb

https://blog.hagander.net/json-field-constraints-228/
https://www.postgresql.org/docs/9.5/datatype-json.html#JSON-INDEXING

CREATE TABLE jsontable (j jsonb NOT NULL);
-- All of the keys - a bit of overkill
CREATE INDEX j_idx ON jsontable USING gin(j jsonb_path_ops);
-- Just one key
CREATE UNIQUE INDEX j_uuid_idx ON jsontable(((j->>'uuid')::uuid));
CREATE INDEX idxgintags ON api USING gin ((jdoc -> 'tags'));
ALTER TABLE jsontable ADD CONSTRAINT uuid_must_exist CHECK (j ? 'uuid');

SELECT count(*) FROM cards WHERE data->>'finished' = 'true';

-> and --> operators

jsonb_path_ops means index can only handle @>
The technical difference between a jsonb_ops and a jsonb_path_ops GIN index is that
jsonb_ops creates independent index items for each key and value in the data,
while jsonb_path_ops creates index items only for each value in the data. 
Basically, each jsonb_path_ops index item is a hash of the value and the
key(s) leading to it.

https://stackoverflow.com/questions/18404055/index-for-finding-an-element-in-a-json-array

CREATE TABLE tracks (id serial, artists jsonb);
CREATE INDEX tracks_artists_gin_idx ON tracks USING gin (artists);

No need for a function to convert the array. This would support a query:

SELECT * FROM tracks WHERE artists @> '[{"name": "The Dirty Heads"}]';

@> being the new jsonb "contains" operator, which can use the GIN index. (Not for type json, only jsonb!)

WEEK 3 - ELASTIC SEARCH
=======================


WEEK 4 - PANDAS AND SQL
=======================




TODO
====

DUMP / RESTORE
--------------

https://www.postgresql.org/docs/9.1/backup-dump.html

pg_dump dbname > outfile

psql dbname < infile

INDEXES AND PERFORMANCE
-----------------------

VIEWS
----- 

You can “hide” complexity with a view.   You can create a view with computed columns, which can prove quite handy. You can limit access by use of views as well restrict certain dB users to read-only views.  


PROCEDURES
----------

Stored Procedures

Before, After, or Instead of INSERT, UPDATE, or DELETE

http://www.postgresqltutorial.com/postgresql-create-procedure/

Triggers

CREATE  TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] [INSERT|UPDATE|DELETE] OF column_name
ON table_name
[
];

TODO
----

WITH / Common Table Expressions

Doing it in Python

PERCENT_RANK

HSTORE :)
