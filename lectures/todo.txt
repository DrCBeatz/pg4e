
COURSE 2
========

WEEK 1 - FULL TEXT SEARCHES
===========================


WEEK 2 - JSON / KEY-VALUE DATA
==============================

CREATE UNIQUE INDEX j_uuid_idx ON jsontable(((j->>'uuid')::uuid));
CREATE INDEX idxgintags ON api USING gin ((jdoc -> 'tags'));
ALTER TABLE jsontable ADD CONSTRAINT uuid_must_exist CHECK (j ? 'uuid');

WEEK 3 - ELASTIC SEARCH
=======================

Lecture 1 - SQL / noSQL

Lecture 2 - Elastic Search

WEEK 4 - PANDAS AND SQL
=======================

https://pandas.pydata.org/pandas-docs/stable/getting_started/comparison/comparison_with_sql.html

https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_sql.html

https://pythondata.com/quick-tip-sqlalchemy-for-mysql-and-pandas/

https://datacarpentry.org/python-ecology-lesson/09-working-with-sql/index.html

https://pythontic.com/pandas/serialization/mysql

https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html

TODO
====

DUMP / RESTORE
--------------

https://www.postgresql.org/docs/9.1/backup-dump.html

pg_dump dbname > outfile

psql dbname < infile

INDEXES AND PERFORMANCE
-----------------------

VIEWS
----- 

You can “hide” complexity with a view.   You can create a view with computed columns, which can prove quite handy. You can limit access by use of views as well restrict certain dB users to read-only views.  


PROCEDURES
----------

Stored Procedures

Before, After, or Instead of INSERT, UPDATE, or DELETE

http://www.postgresqltutorial.com/postgresql-create-procedure/

Triggers

CREATE  TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] [INSERT|UPDATE|DELETE] OF column_name
ON table_name
[
];

TODO
----

WITH / Common Table Expressions

Doing it in Python

PERCENT_RANK

HSTORE :)
